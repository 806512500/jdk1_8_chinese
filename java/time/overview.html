html
<body>
    <p>
        Java 的新日期和时间 API。
        设计包括相对较多的类和方法，
        但每个类和方法都遵循共同的设计语言，特别是在方法前缀方面。
        一旦理解了这些前缀，API 就相对容易理解。
    </p>
    <p>
        Java Time API 由几个包组成，每个包都有其主要功能：
    </p>
    <p>
        {@link java.time} 包含基于 ISO-8601 标准的主要 API。
        在这里定义的类表示主要的日期时间概念，
        包括时间点、持续时间、日期、时间、时区和周期。
        它们基于 ISO 日历系统，这是按照公历规则的 <i>事实上的</i> 世界日历。
        所有类都是不可变的并且线程安全。
    </p>
    <p>
        {@link java.time.temporal} 包含访问日期时间字段和单位的 API。
        单位是可以测量的，例如年、月和小时。
        例如，表达式“2 小时后”使用小时单位。
        相比之下，字段是小型计算，定义一个值。
        例如，月-年、周-日和小时-日都是字段。
        如果需要，应用程序可以扩展支持的单位和字段。
    </p>
    <p>
        {@link java.time.format} 包含将字段打印和解析为日期时间对象以及自定义解析和打印的 API。
        可以通过多种方式创建格式化器，包括常量、模式、本地化样式和构建器。
        格式化器是不可变的并且线程安全。
    </p>
    <p>
        {@link java.time.zone} 包含处理时区的 API。
        提供了关于每个时区规则的详细信息。
    </p>
    <p>
        {@link java.time.chrono} 包含日历中立 API 的基本部分和替代日历系统。
        这旨在供需要使用本地化日历的应用程序使用。
        提供了对希吉拉历、日本历、民国历和泰历的支持。
    </p>
    <h3>设计说明</h3>
    <p>
        在可能的情况下，API 避免使用 null。
        所有方法都在 Javadoc 中定义了它们是否接受或返回 null。
        通常情况下，方法不接受或返回 null。
        一个关键的例外是任何接受对象并返回布尔值的方法，用于检查或验证，通常会为 null 返回 false。
    </p>
    <p>
        API 在主高级 API 中尽可能地设计为类型安全。
        因此，日期、时间、日期时间以及偏移和时区的不同概念都有单独的类。
        核心的 7 个日期时间类，加上 Instant，可以满足大多数应用程序的需求。
        其他类处理其他组合，例如年、年-月和月-日，以类型安全的方式。
    </p>
    <p>
        在像 Java 这样的语言中，使用许多不同类型的倾向会导致 API 膨胀。
        这里通过在整个 API 中使用通用的方法命名模式来处理。
        常见的前缀是 'of'、'get'、'is'、'with'、'plus'、'minus'、'to' 和 'at'。
        请参见 {@link java.time.LocalDate} 以了解这些方法的示例。
    </p>
    <p>
        从类型安全的逻辑结论来看，会导致更多的类，特别是对于时间 -
        小时-分钟、小时-分钟-秒和小时-分钟-秒-纳秒。
        虽然逻辑上是纯粹的，但在实践中是不可能的，因为额外的类会使 API 过于复杂。
        特别是，在偏移和日期时间级别会有额外的组合，例如偏移-日期-小时-分钟。
        为了避免这种类型爆炸，{@link java.time.LocalTime} 用于所有时间精度。
        相比之下，日期使用了一些额外的类，例如 {@link java.time.YearMonth}。
        这被证明是必要的，因为年-月的 API 与日期的 API 有显著不同，而时间中没有纳秒可以通过返回零来近似。
    </p>
    <p>
        同样，完全的类型安全可能会为日期时间中的每个字段单独创建一个类，
        例如一个 HourOfDay 类和一个 DayOfMonth 类。
        这种方法在 Java 语言中尝试过，但过于复杂，缺乏可用性。
        类似的问题也出现在周期中。
        有理由为每个周期单位创建一个单独的类，例如一个 Years 类和一个 Minutes 类。
        然而，这会产生很多类和类型转换的问题。
        因此，字段和单位的一般访问没有包装在一个类中。
    </p>
    <p>
        多个日历系统是设计挑战中的一个棘手问题。
        第一个原则是大多数用户需要标准的 ISO 日历系统。
        因此，主要类是仅 ISO 的。第二个原则是大多数需要非 ISO 日历系统的用户需要它进行用户交互，因此这是一个 UI 本地化问题。
        因此，日期和时间对象应在数据模型和持久存储中作为 ISO 对象持有，仅在显示时转换为本地日历。
        日历系统应单独存储在用户偏好设置中。
    </p>
    <p>
        然而，有一些有限的用例，用户认为他们需要在整个应用程序中存储和使用任意日历系统的日期。
        这由 {@link java.time.chrono.ChronoLocalDate} 支持，但在使用它之前必须仔细阅读该接口的 Javadoc 中的所有相关警告。
        总的来说，需要在多个日历系统之间进行通用互操作的应用程序通常需要以与仅使用 ISO 日历的应用程序非常不同的方式编写，
        因此大多数应用程序应仅使用 ISO 并避免使用 {@code ChronoLocalDate}。
    </p>
    <p>
        在所有这些过程中，一个关键目标是允许应用程序定义日期时间字段和单位。
        这是通过尝试许多不同的设计来实现的。
    </p>
</body>
