/*
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 *
 *
 *
 *
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent.locks;

/**
 * 一个 {@code ReadWriteLock} 维护了一对相关的 {@link
 * Lock 锁}，一个用于只读操作，另一个用于写入。
 * {@link #readLock 读锁} 可以同时被多个读取线程持有，只要没有写入者。 {@link #writeLock 写锁} 是独占的。
 *
 * <p>所有 {@code ReadWriteLock} 实现必须保证 {@code writeLock} 操作的内存同步效果
 * （如 {@link Lock} 接口所指定）也适用于相关的 {@code readLock}。也就是说，成功获取读锁的线程将看到所有之前释放写锁时所做的更新。
 *
 * <p>读写锁允许比互斥锁更高的并发访问共享数据。
 * 它利用了这样一个事实：虽然一次只能有一个线程（一个 <em>写入者</em> 线程）修改共享数据，但在许多情况下，任何数量的线程都可以并发地读取数据（因此称为 <em>读取者</em> 线程）。
 * 从理论上讲，使用读写锁允许的并发增加将比使用互斥锁的性能有所提高。实际上，这种并发的增加只有在多处理器上才能完全实现，并且只有在共享数据的访问模式适合时才能实现。
 *
 * <p>读写锁是否比互斥锁提高性能取决于数据被读取的频率与被修改的频率、读写操作的持续时间以及对数据的争用情况——即同时尝试读取或写入数据的线程数量。
 * 例如，一个最初用数据填充，之后很少被修改，但经常被搜索的集合（如某种目录）是使用读写锁的理想候选。然而，如果更新变得频繁，那么数据大部分时间都在被独占锁定，几乎没有并发性的增加。此外，如果读操作太短，读写锁实现的开销（本质上比互斥锁更复杂）可能会主导执行成本，特别是许多读写锁实现仍然在一小段代码中序列化所有线程。最终，只有通过分析和测量才能确定读写锁是否适合您的应用程序。
 *
 *
 * <p>尽管读写锁的基本操作是直截了当的，但实现必须做出许多策略决策，这可能会影响读写锁在给定应用程序中的有效性。这些策略的示例包括：
 * <ul>
 * <li>确定当写入者释放写锁时，如果有读取者和写入者都在等待，是授予读锁还是写锁。写入者优先是常见的，因为预计写入是短暂且不频繁的。读取者优先较少见，因为它可能导致写入者长时间延迟，如果读取者频繁且持续时间长。也可以实现公平或“按顺序”的策略。
 *
 * <li>确定当读取者活跃且写入者等待时，请求读锁的读取者是否被授予读锁。优先考虑读取者可能会无限期地延迟写入者，而优先考虑写入者可能会减少并发的潜力。
 *
 * <li>确定锁是否可重入：持有写锁的线程是否可以重新获取它？它是否可以在持有写锁的同时获取读锁？读锁本身是否可重入？
 *
 * <li>写锁是否可以降级为读锁而不允许中间写入？读锁是否可以升级为写锁，优先于其他等待的读取者或写入者？
 *
 * </ul>
 * 在评估给定实现是否适合您的应用程序时，您应该考虑所有这些因素。
 *
 * @see ReentrantReadWriteLock
 * @see Lock
 * @see ReentrantLock
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface ReadWriteLock {
    /**
     * 返回用于读取的锁。
     *
     * @return 用于读取的锁
     */
    Lock readLock();

    /**
     * 返回用于写入的锁。
     *
     * @return 用于写入的锁
     */
    Lock writeLock();
}
